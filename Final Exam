{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "g4pubNpYkUId"
   },
   "source": [
    "# Final Exam Project\n",
    "**Course** : Foundations of Data Science: Programming and Linear Algebra\n",
    "\n",
    "**Student 1** : Annaya Thammalokapitak\n",
    "**Student 2** : Danielle V. Duncan\n",
    "\n",
    "**Date** : 20/Dec/2021\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "fa2n-XNdlaJZ"
   },
   "source": [
    "## Question 1\n",
    "\n",
    "**[Sub-Numpy]**\n",
    "\n",
    "\n",
    "Creation of a simple Numpy like class with some of the similar functionalities of the popular Numpy package.\n",
    "\n",
    "The specifications of the class is as follow:\n",
    "1. snp.ones(Int) : the ones function takes an int parameter and returns an array (list) of length\n",
    "int parameter and the array contains only ones. Example: snp.ones(5) = [1,1,1,1,1]\n",
    "2. snp.zeros(Int): similar to the ones function, expect returns an array of zeros instead of ones.\n",
    "3. snp.reshape(array, (row, column)) : takes an array and converts it into the dimensions specified\n",
    "by the tuple (row, column). Hence this function converts from a vector to a matrix. For an\n",
    "example on reshape functionality of numpy, refer to fig. 1.\n",
    "4. snp.shape(array) : returns a tuple with the matrix/vector’s dimension e.g. (# rows, # columns).\n",
    "5. snp.append(array1, array2) : returns a new vector/matrix that is the combination of the two\n",
    "input vectors/matrices. Note that you can’t append a vector to a matrix and vice versa and\n",
    "therefore use suitable exception handling and throw/return user friendly error messages.\n",
    "6. snp.get(array, (row, column)) : returns the value specified by the coordinate point (row, column) of the array provided (can be vector or matrix).\n",
    "7. snp.add(array1, array1) : addition on vectors/matrices.\n",
    "8. snp.subtract(array1, array1) : subtraction on vectors/matrices.\n",
    "9. snp.dotproduct(array1, array1) : computes the dot product between two arrays (which could\n",
    "be vector or/and matrix) and returns an appropriate value. Use appropriate exception handling\n",
    "to output user-friend\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "id": "fvKOSEULmHpg"
   },
   "outputs": [],
   "source": [
    "# Below see the implemented solution, the test and discussion will be covered in the subsection below\n",
    "\n",
    "class Snumpy(object):\n",
    "    \"\"\"\n",
    "    Numpy-like class with some of the similar functionalities of the popular Numpy package.\n",
    "    \n",
    "    Dictionary: \n",
    "        array = [1,2,3]\n",
    "        vector/row vector = [1,2,3]\n",
    "        column vector = [[1],[2],[3]]\n",
    "        matrix = [[1,2,3],[4,5,6]]\n",
    "    \"\"\"\n",
    "        \n",
    "    def ones(num):\n",
    "        \"\"\"\n",
    "        The ones function takes an int parameter and returns an array (list) of length int parameter \n",
    "        and the array contains only ones. Example: snp.ones(5) = [1,1,1,1,1]\n",
    "        input:\n",
    "          sum : int\n",
    "        return: List\n",
    "        \"\"\"\n",
    "        ones_list = []\n",
    "        # control input type with asert\n",
    "        assert type(num) == int, \"Input must be int type.\"\n",
    "        assert num >= 0, \"Input must have the value equal or more than 0\"\n",
    "        for i in range(num):\n",
    "              ones_list.append(1)\n",
    "        return ones_list\n",
    "    \n",
    "    def zeros(num):\n",
    "        \"\"\"\n",
    "        The zeros function takes an int parameter and returns an array (list) of length int parameter \n",
    "        and the array contains only zeros. Example: snp.zeros(5) = [0,0,0,0,0]\n",
    "        input:\n",
    "          sum : int\n",
    "        return: List\n",
    "        \"\"\"\n",
    "        zeros_list = []\n",
    "        #control input type with assert\n",
    "        assert type(num) == int, \"Input must be int type.\"\n",
    "        assert num >= 0, \"Input must have the value equal or more than 0\"\n",
    "        for i in range(num):\n",
    "            zeros_list.append(0)\n",
    "        return zeros_list\n",
    "        \n",
    "    def reshape(matrix, dimension):\n",
    "        \"\"\"\n",
    "        Snumpy.reshape(array, (row, column)) : takes an array or a matrix and converts it into the dimensions specified\n",
    "        by the tuple (row, column). Hence, this function converts from a vector to a matrix. For an\n",
    "        example: matrix = [[1,2,3,4,5,6]] dimension = (6,1) new_shape = [[1],[2],[3],[4],[5],[6]]\n",
    "                 row vector(array) =[1,2,3,4,5,6] dimension = (2,3) new_shape = [[1,2,3],[4,5,6]]\n",
    "        \"\"\"\n",
    "        # control input type with assert\n",
    "        assert type(dimension) == tuple\n",
    "        assert len(dimension) == 2, \"only 2 dimensions are allowed\"\n",
    "        (row, column) = dimension\n",
    "        assert type(row) == int and type(column) == int , \"row and column values must be of type int\"\n",
    "        new_shape = []\n",
    "        array= []\n",
    "        assert type(matrix) == list, \"The input must be in an array of numbers or a matrix\"\n",
    "        \n",
    "        # convert input matrix or array into one long array\n",
    "        for num in matrix:\n",
    "            if type(num) is list:\n",
    "                for i in num:\n",
    "                    array.append(i)\n",
    "            else:\n",
    "                array.append(num)\n",
    "\n",
    "        #check if the given dimension is possible for reshaping\n",
    "        assert len(array) == row*column, \"cannot reshape array of size \"+str(len(array))+\" into shape\"+ str(dimension)\n",
    "        #convert the array to a matrix\n",
    "        for m in range(row):\n",
    "            new_row = []\n",
    "            for n in range(column):\n",
    "                new_row.append(array[column*m+n])\n",
    "            new_shape.append(new_row)\n",
    "        return new_shape\n",
    "       \n",
    "    def shape(matrix):\n",
    "        \"\"\"\n",
    "        Snumpy.shape(array) : returns a tuple with the matrix/vector’s dimension e.g. (# rows, # columns)\n",
    "        For example: matrix = [[1,2],[3,4]], array =(2,2)\n",
    "                     row vector(array) =[1,2,3,4], array = (4,0)\n",
    "        \"\"\"\n",
    "        #control input type\n",
    "        assert type(matrix) == list , \"input must to be of type list\"\n",
    "        assert len(matrix) > 0 , \"input cannot be a empty list, for it is neither a vector nor a matrix\"\n",
    "        \n",
    "        #if condition for when input is an array \n",
    "        if type(matrix[0])==int or type(matrix[0])==float:\n",
    "            row = len(matrix)\n",
    "            column = 0\n",
    "            array = (row, column)\n",
    "            return (array)\n",
    "        #else condition for when input is a matrix\n",
    "        else:\n",
    "            #for loop to check if the number of columns is the same in all rows   \n",
    "            for i in range(len(matrix)):\n",
    "                if i<len(matrix)-1:\n",
    "                    if len(matrix[i])!=len(matrix[i+1]):\n",
    "                        return (\"Matrix must be an even shape\")\n",
    "                else:\n",
    "                    column = len(matrix[0])\n",
    "                    row = len(matrix)\n",
    "                    array = (row, column)\n",
    "                    return (array)\n",
    "    \n",
    "    def append(array1, array2, axis = 0):\n",
    "        \"\"\"\n",
    "        Snumpy.append(array1, array2) : returns a new vector/matrix that is the combination of the two\n",
    "        input vectors/matrices. Note: you can’t append a vector to a matrix and vice versa.\n",
    "            axis = None; the output will be a flattened array of the inputs\n",
    "            axis = 0; append number of rows to array1 on the condition that the number of columns of the inputs is the same\n",
    "            axis = 1; append number of columns to array1 on the condition that the number of rows of the inputs is the same\n",
    "        \"\"\"\n",
    "        new_array =[]\n",
    "        #control input type and value\n",
    "        assert axis in [None, 0 , 1] , \"axis has to be value 0, 1 or None\"\n",
    "        assert type(array1) == list and type(array2) == list , \"input 1 and 2 has to be of type List\"\n",
    "    \n",
    "        #We divide the calculation into 3 conditions by the axis input as None, 1, then 0\n",
    "        if axis == None:\n",
    "            # We avoid using nested for loop to flatten matrices to improve big O\n",
    "            if type(array1[0]) == list: \n",
    "                dim_reshaped1 = Snumpy.shape(array1)[0]*Snumpy.shape(array1)[1]\n",
    "                dim_reshaped2 = Snumpy.shape(array2)[0]*Snumpy.shape(array2)[1]\n",
    "            else:\n",
    "                dim_reshaped1 = Snumpy.shape(array1)[0]\n",
    "                dim_reshaped2 = Snumpy.shape(array2)[0]\n",
    "            temp_array = []\n",
    "            array1 = Snumpy.reshape(array1,(1,dim_reshaped1))\n",
    "            array2 = Snumpy.reshape(array2,(1,dim_reshaped2))\n",
    "            temp_array.extend(array1)\n",
    "            temp_array.extend(array2)\n",
    "            for i in range(2):   \n",
    "                new_array.extend(temp_array[i])\n",
    "\n",
    "        elif axis == 1:\n",
    "          # control input value\n",
    "            assert Snumpy.shape(array1)[1] != 0 , \"Axis 1 is out of bounds for array of dimension 1\"\n",
    "            assert Snumpy.shape(array1)[0] == Snumpy.shape(array2)[0] ,\"Both matrices must have the same number of columns\"\n",
    "          \n",
    "            for i in range(len(array1)): \n",
    "                new_row = []\n",
    "                new_row.extend(array1[i])\n",
    "                new_row.extend(array2[i])\n",
    "                new_array.append(new_row)\n",
    "\n",
    "        else :\n",
    "            if Snumpy.shape(array1)[1] != 0:\n",
    "            #control input value\n",
    "                assert Snumpy.shape(array1)[1] == Snumpy.shape(array2)[1] ,\"Both matrices must have the same number of rows\"\n",
    "                \n",
    "                for i in range(len(array1)): \n",
    "                    new_array.append(array1[i])\n",
    "                for i in range(len(array2)):\n",
    "                    new_array.append(array2[i])\n",
    "            else:\n",
    "                new_array.extend(array1)\n",
    "                new_array.extend(array2)\n",
    "        return new_array\n",
    "        \n",
    "        \n",
    "    def get(array, dimension):\n",
    "        \"\"\"\n",
    "        Snumpy.get(array, (row, column)) : returns the value specified by the coordinate point (row, column) \n",
    "        of the array provided (can be vector or matrix)\n",
    "        For example: array = [1,2,3,4] dimension (2,0) get_num = 2\n",
    "                     matrix = [[1,2,3],[4,5,6]] dimension (2,3) get_num = 6\n",
    "        \"\"\"\n",
    "        # control input type with assert\n",
    "        assert type(dimension) == tuple, \"dimension must be of type tuple\"\n",
    "        assert len(dimension) == 2, \"only 2 dimensions is allowed\"\n",
    "        (row, column) = dimension\n",
    "        assert type(row) == int and type(column) == int, \"row and column values must be of type int\"\n",
    "        \n",
    "        # if condition for when the input is an array\n",
    "        if type(array[0]) == int or type(array[0]) == float:\n",
    "            get_num = array[row-1]\n",
    "        \n",
    "        # else condition for when the input is a matrix\n",
    "        else:       \n",
    "            row1 = row-1\n",
    "            column1 = column-1\n",
    "            get_num = array[row1][column1]\n",
    "          \n",
    "        return get_num\n",
    "    \n",
    "    def add(array1, array2):\n",
    "        \"\"\"\n",
    "        Snumpy.add(array1, array2) : addition on vectors/matrices.\n",
    "        \"\"\"\n",
    "        # control input type and value\n",
    "        assert type(array1) == list and type(array2) == list, \"input must be an array or a matrix\" \n",
    "        assert len(array1) == len(array2), \"input must be the same size\"\n",
    "        \n",
    "        # if condition for when the input is a matrix\n",
    "        if type(array1[0]) != int:\n",
    "            #control input value; array1 and array2 must be the same size\n",
    "            assert Snumpy.shape(array1)[1] == Snumpy.shape(array2)[1], \"input matrix must have the same number of columns\"\n",
    "            \n",
    "            for i in range(len(array1)): \n",
    "                for j in range(len(array1[0])): \n",
    "                    array1[i][j] += array2[i][j]\n",
    "            return array1\n",
    "        \n",
    "        # elif condition for when the input is an array, also control input type as int\n",
    "        elif type(array1[0]) == int: \n",
    "            for i in range(len(array1)):\n",
    "                array1[i] += array2[i]\n",
    "            return array1\n",
    "    \n",
    "    def subtract(array1, array2):\n",
    "        \"\"\"\n",
    "        Snumpy.subtract(array1, array1) : substraction on vectors/matrices.\n",
    "        \"\"\"\n",
    "        # control input type and value\n",
    "        assert type(array1) == list and type(array2) == list, \"input must be an array or a matrix\" \n",
    "        assert len(array1) == len(array2), \"input must be the same size\"\n",
    "        \n",
    "        # if condition for when the input is a matrix\n",
    "        if type(array1[0]) != int:\n",
    "            #control input value; array1 and array2 must be the same size\n",
    "            assert Snumpy.shape(array1)[1] == Snumpy.shape(array2)[1], \"input matrix must have the same number of columns\"\n",
    "            \n",
    "            for i in range(len(array1)): \n",
    "                for j in range(len(array1[0])): \n",
    "                    array1[i][j] -= array2[i][j]\n",
    "            return array1\n",
    "        \n",
    "        # elif condition for when the input is an array, also control input type as int\n",
    "        elif type(array1[0]) == int: \n",
    "            for i in range(len(array1)):\n",
    "                array1[i] -= array2[i]\n",
    "            return array1\n",
    "    \n",
    "    def dotproduct(A, B):\n",
    "        \"\"\"\n",
    "        Snumpy.dotproduct(array1, array2) : computes the dot product between two arrays (which could\n",
    "        be vector or/and matrix) and returns an appropriate value. Use appropriate exception handling\n",
    "        to output user-friendly error messages in case the dot product cannot be performed between\n",
    "        the given arrays.\n",
    "        For example: array1 = [1,1,1,1] array2 = [1,1,1,1] final_matrix = 4\n",
    "                    matrix1 = [[1,1,1]] matrix2 = [[2],[2],[2]] final_matrix = [[6]]\n",
    "        \"\"\"\n",
    "        # control input type\n",
    "        assert type(A) == list and type(B) == list, \"input must be an array or a matrix\" \n",
    "        \n",
    "        # if condition for when the inputs are arrays, also control input type as int or float\n",
    "        if type(A[0]) == int or type(A[0]) == float :\n",
    "            final_matrix = 0\n",
    "            #control input value\n",
    "            assert len(A) == len(B), \"The arrays must be the same lenght.\"\n",
    "            for i in range(len(A)):\n",
    "                final_matrix += A[i]*B[i] \n",
    "        else :\n",
    "            dimA=Snumpy.shape(A)\n",
    "            dimB=Snumpy.shape(B)\n",
    "            colA = dimA[1]\n",
    "            rowA = dimA[0]\n",
    "\n",
    "            colB = dimB[1]\n",
    "            rowB =  dimB[0]\n",
    "            \n",
    "            #control input value; the input matrices must meet the condition for matrix dot product\n",
    "            assert colA == rowB, \"Dot product cannot be found.\"\n",
    "\n",
    "            array_c = Snumpy.zeros(rowA*colB)\n",
    "            C = Snumpy.reshape(array_c, (rowA,colB))\n",
    "\n",
    "            final_matrix = Snumpy.dotproductfunc(A, B, C)\n",
    "        \n",
    "        return final_matrix\n",
    "\n",
    "    def dotproductfunc(A, B, C):\n",
    "        \"\"\"\n",
    "        Helper function for the dot product calculation\n",
    "        \"\"\"\n",
    "        # use nested for loop to create the result matrix(C)\n",
    "        for x in range(len(A)):\n",
    "            for y in range(len(B[0])):\n",
    "                for z in range(len(B)):\n",
    "                    C[x][y] += A[x][z] * B[z][y]\n",
    "        return C\n",
    "\n",
    "    # Helper Function used as part of question 2 to allow put in the message as a string of numbers\n",
    "    def create_vector(num):\n",
    "        \"\"\"\n",
    "        Helper function creates a column vector from a string of number.\n",
    "        Example: num = '1101' newvec = [[1],[1],[0],[1]]\n",
    "        input:\n",
    "          sum : int\n",
    "        return: List\n",
    "        \"\"\"\n",
    "        # control input type\n",
    "        try:\n",
    "            veclist = [int(x) for x in str(num)]\n",
    "        except:\n",
    "            raise ValueError('Input must be a string of number')\n",
    "        row=len(veclist)\n",
    "        newvec=Snumpy.reshape(veclist,(row,1))\n",
    "        return newvec"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "hnWjaWTIDVlj"
   },
   "source": [
    "### Test Question 1: Snumpy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "IE0I0zo5l1dI"
   },
   "source": [
    "### Question 1.1\n",
    "\n",
    "snp.ones(Int) : the ones function takes an int parameter and returns an array (list) of length\n",
    "int parameter and the array contains only ones. Example: snp.ones(5) = [1,1,1,1,1]\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "id": "sEmaDahtoe8F"
   },
   "outputs": [],
   "source": [
    "#Test if the function works as intended\n",
    "assert Snumpy.ones(5) ==  [1,1,1,1,1]\n",
    "assert Snumpy.ones(1) ==  [1]\n",
    "assert Snumpy.ones(0) ==  []\n",
    "\n",
    "#Test input type\n",
    "\n",
    "#input is wrong value\n",
    "try :\n",
    "    Snumpy.ones(-1)\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"Input must have the value equal or more than 0\"\n",
    "\n",
    "    #input is wrong type\n",
    "try :\n",
    "    Snumpy.ones(\"string\")\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"Input must be int type.\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "9OnfqPlNqFyX"
   },
   "source": [
    "### Question 1.2\n",
    "\n",
    "snp.zeros(Int): similar to the ones function, expect returns an array of zeros instead of ones.\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "id": "ni4eGdwpoe-U"
   },
   "outputs": [],
   "source": [
    "#Test if the function works as intended\n",
    "assert Snumpy.zeros(5) ==  [0,0,0,0,0]\n",
    "assert Snumpy.zeros(1) ==  [0]\n",
    "assert Snumpy.zeros(0) ==  []\n",
    "\n",
    "#Test input type\n",
    "    #input is wrong value\n",
    "try :\n",
    "    Snumpy.zeros(-1)\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"Input must have the value equal or more than 0\"\n",
    "\n",
    "    #input is wrong type\n",
    "try :\n",
    "    Snumpy.zeros(\"string\")\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"Input must be int type.\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "hL1IgZ4zqYPu"
   },
   "source": [
    "### Question 1.3\n",
    "\n",
    "Snumpy.reshape(array, (row, column)) : takes an array and converts it into the dimensions specified by the tuple (row, column). Hence this function converts from a vector to a matrix. For an example on reshape functionality of numpy.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "id": "En4mO4y4qQNy"
   },
   "outputs": [],
   "source": [
    "#Test if the function works as intended with vector input\n",
    "assert Snumpy.reshape([1,1,1,1],(2,2)) == [[1, 1], [1, 1]]\n",
    "assert Snumpy.reshape([1,1,1,1],(1,4)) == [[1, 1, 1, 1]]\n",
    "assert Snumpy.reshape([1,1,1,1],(4,1)) == [[1], [1], [1], [1]]\n",
    "assert Snumpy.reshape([1,2,0,3,5,4],(2,3)) == [[1, 2, 0], [3, 5, 4]]\n",
    "                                               \n",
    "#Test if the function works as intended with matrix input\n",
    "assert Snumpy.reshape([[1,2],[3,4],[5,6]],(2,3)) == [[1, 2, 3], [4, 5, 6]]\n",
    "assert Snumpy.reshape([[1,2],[3,4],[5,6]],(3,2)) == [[1,2],[3,4],[5,6]]\n",
    "assert Snumpy.reshape([[1,2],[3,4],[5,6]],(1,6)) == [[1,2,3,4,5,6]]\n",
    "\n",
    "#Test reshaping a vector to the matrix with impossible dimension\n",
    "try :\n",
    "    Snumpy.reshape([1,2,0,3,5],(2,3))\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"cannot reshape array of size 5 into shape(2, 3)\"\n",
    "\n",
    "#Test input type of dimension\n",
    "try :\n",
    "    Snumpy.reshape([1,2,0,3,5,6],(\"2\",3))\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"row and column values must be of type int\"\n",
    "\n",
    "#Test input type of matrix\n",
    "try :\n",
    "    Snumpy.reshape(\"[1,2,0,3,5,6]\",(2,3))\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"The input must be in an array of numbers or a matrix\"\n",
    "\n",
    "#Test the condition of dimension\n",
    "try :\n",
    "    Snumpy.reshape(\"[1,2,0,3,5,6]\",(2,3,1))\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"only 2 dimensions is allowed\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "RRFlMZIWquRF"
   },
   "source": [
    "### Question 1.4\n",
    "\n",
    "Snumpy.shape(array) : returns a tuple with the matrix/vector’s dimension e.g. (# rows, # columns)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "id": "y8oX9NZPqQQD"
   },
   "outputs": [],
   "source": [
    "#Test if the shape appeared as intended for matrices\n",
    "assert (2,2) == Snumpy.shape([[1, 1], [1, 1]])\n",
    "assert (1,4) == Snumpy.shape([[1, 1, 1, 1]])\n",
    "assert (4,1) == Snumpy.shape([[1], [1], [1], [1]])\n",
    "assert (2,3) == Snumpy.shape([[1, 2, 0], [3, 5, 4]])\n",
    "\n",
    "#Test if the shape appeared as intended for vectors\n",
    "assert (4, 0) == Snumpy.shape([1,1,1,1])\n",
    "\n",
    "#Test wrong input\n",
    "    #input is wrong value\n",
    "try :\n",
    "    Snumpy.shape([])\n",
    "    raise BaseException(\"The code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input cannot be a empty list, then it is neither a vector nor a matrix\"\n",
    "\n",
    "    #input is wrong type\n",
    "try :\n",
    "    Snumpy.shape(\"string\")\n",
    "    raise BaseException(\"The code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input have to be of type list\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "-2BvFlWQyk29"
   },
   "source": [
    "\n",
    "### Question 1.5\n",
    "\n",
    "Snumpy.append(array1, array2) : returns a new vector/matrix that is the combination of the two input vectors/matrices. Note that you can’t append a vector to a matrix and vice versa and therefore use suitable exception handling and throw/return user friendly error messages."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "id": "Dqn0MX5l8vD2"
   },
   "outputs": [],
   "source": [
    "# Test if the function works as intended when input are vectors\n",
    "assert Snumpy.append([1, 2], [3, 4], axis= None) == [1, 2, 3, 4]\n",
    "assert Snumpy.append([1, 2], [3, 4, 5], axis=None) == [1, 2, 3, 4, 5]\n",
    "assert Snumpy.append([1, 2], [3, 4], axis=0) == [1, 2, 3, 4]\n",
    "assert Snumpy.append([1, 2], [3, 4, 5], axis=0) == [1, 2, 3, 4, 5]\n",
    "\n",
    "#input is wrong value\n",
    "try :\n",
    "    Snumpy.append([1, 2], [3, 4], axis=1)\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"Axis 1 is out of bounds for array of dimension 1\"\n",
    "\n",
    "# Test if the function works as intended when input are matrices\n",
    "assert Snumpy.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9],[7, 8, 9]], axis=None) == [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 7, 8, 9]\n",
    "assert Snumpy.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9],[7, 8, 9]], axis=0) == [[1, 2, 3], [4, 5, 6], [7, 8, 9], [7, 8, 9]]\n",
    "assert Snumpy.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9],[7, 8, 9]], axis=1) == [[1, 2, 3, 7, 8, 9], [4, 5, 6, 7, 8, 9]]\n",
    "    #test matrices with the same number of columns while axis =0\n",
    "assert Snumpy.append([[1, 2, 3]], [[7, 8, 9],[7, 8, 9]], axis=0) == [[1, 2, 3], [7, 8, 9], [7, 8, 9]]\n",
    "    #test matrices with the same number of rows while axis = 1\n",
    "assert Snumpy.append([[1, 2],[3,4]], [[7, 8, 9],[7, 8, 9]], axis = 1) == [[1,2,7,8,9],[3,4,7,8,9]]\n",
    "\n",
    "# Test wrong inputs\n",
    "    #input is wrong size; columns\n",
    "try :\n",
    "    Snumpy.append([[1, 2, 3]], [[7, 8, 9],[7, 8, 9]], axis=1)\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"Both matrices must have the same number of columns\"\n",
    "\n",
    "    #input is wrong size; rows\n",
    "try :\n",
    "    Snumpy.append([[1, 2, 3], [4, 5, 6]], [[7, 8],[7, 8]], axis=0)\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"Both matrices must have the same number of rows\"\n",
    "\n",
    "    #input wrong value; axis value can be only None,0,1\n",
    "try :\n",
    "    Snumpy.append([[1, 2, 3], [4, 5, 6]], [[7, 8],[7, 8]], axis=2)\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"axis has to be value 0, 1 or None\"\n",
    "\n",
    "    #input wrong type; axis value must be int or None\n",
    "try :\n",
    "    Snumpy.append([[1, 2, 3], [4, 5, 6]], [[7, 8],[7, 8]], axis=\"0\")\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"axis has to be value 0, 1 or None\"\n",
    "\n",
    "    #input is wrong type; arrays must be of type list\n",
    "try :\n",
    "    Snumpy.append([[1, 2, 3], [4, 5, 6]], \"[[7, 8],[7, 8]]\", axis=1)\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input 1 and 2 has to be of type List\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "RF7YAMQYys5x"
   },
   "source": [
    "### Question 1.6\n",
    "\n",
    "snp.get(array, (row, column)) : returns the value specified by the coordinate point (row, column) of the array provided (can be vector or matrix)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "id": "biu2qHDgy9CG"
   },
   "outputs": [],
   "source": [
    "# Test if the function works as intended when input is a vector\n",
    "assert Snumpy.get([1,2,3,4,5], (1, 0)) == 1\n",
    "# Test if the function works as intended when input is a matrix\n",
    "assert Snumpy.get([[1,2,3],[4,5,6]], (2, 1)) == 4\n",
    "\n",
    "# Test wrong inputs\n",
    "    # input is wrong type; dimension must be of type int\n",
    "try :\n",
    "    Snumpy.get([1,2,3,4,5], (3.2, 0))\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"row and column values must be of type int\"\n",
    "\n",
    "    # input is wrong type; dimension must be of type tuple\n",
    "try :\n",
    "    Snumpy.get([1,2,3,4,5], [1,2])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"dimension must be of type tuple\"\n",
    "\n",
    "    #input is wrong size; dimension must have lenght of 2\n",
    "try :\n",
    "    Snumpy.get([1,2,3,4,5], (1,2,3))\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"only 2 dimensions is allowed\"  \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "czlxjxMOy-U0"
   },
   "source": [
    "### Question 1.7\n",
    "\n",
    "Snumpy.add(array1, array2) : addition on vectors/matrices."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "id": "SGuYT3OrzImm"
   },
   "outputs": [],
   "source": [
    "# Test if the function works as intended when input is a vector\n",
    "assert Snumpy.add([1,2,3],[1,1,1]) == [2,3,4]\n",
    "# Test if the function works as intended when input is a matrix\n",
    "assert Snumpy.add([[1,2],[3,4]],[[1,1],[1,1]]) == [[2,3],[4,5]]\n",
    "\n",
    "# Test wrong inputs\n",
    "    #input is wrong type\n",
    "try :\n",
    "    Snumpy.add(\"str\",[1,2,3])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input must be an array or a matrix\"\n",
    "\n",
    "    #input is wrong size\n",
    "try :\n",
    "    Snumpy.add([1,1,1,1],[1,2,3])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input must be the same size\" "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "g2AOvsvCzI9-"
   },
   "source": [
    "### Question 1.8\n",
    "\n",
    "Snumpy.subtract(array1, array2) : subtraction on vectors/matrices."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "id": "6-IqXcEVzPzH"
   },
   "outputs": [],
   "source": [
    "# Test if the function works as intended when input is a vector\n",
    "assert Snumpy.subtract([1,2,3],[1,1,1]) == [0,1,2]\n",
    "# Test if the function works as intended when input is a matrix\n",
    "assert Snumpy.subtract([[1,2],[3,4]],[[1,1],[1,1]]) == [[0,1],[2,3]]\n",
    "\n",
    "# Test wrong inputs\n",
    "    # input in str type\n",
    "try :\n",
    "    Snumpy.subtract(\"str\",[1,2,3])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input must be an array or a matrix\"\n",
    "\n",
    "    # inputs are wrong size\n",
    "try :\n",
    "    Snumpy.subtract([1,1,1,1],[1,2,3])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input must be the same size\" "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "i0f2OIKTzP7P"
   },
   "source": [
    "### Question 1.9\n",
    "\n",
    "Snumpy.dotproduct(array1, array1) : computes the dot product between two arrays (which could be vector or/and matrix) and returns an appropriate value. Use appropriate exception handling to output user-friend"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "id": "BoMiLykJzVb5"
   },
   "outputs": [],
   "source": [
    "# Test if the function works as intended when input is a vector\n",
    "assert Snumpy.dotproduct([1,1,1,1],[1,1,1,1]) == 4\n",
    "# Test if the function works as intended when input is a matrix\n",
    "assert Snumpy.dotproduct([[1,1,1]],[[2],[2],[2]]) == [[6]]\n",
    "\n",
    "#Test wrong inputs\n",
    "    #Test input as tuple\n",
    "try :\n",
    "    Snumpy.dotproduct((1,1,1,1),[[1],[1],[1],[1]])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input must be an array or a matrix\"\n",
    "\n",
    "    #test inputs which cannot operate dot product \n",
    "try :\n",
    "    Snumpy.dotproduct([[1,1,1]],[[1],[1],[1],[1]])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"Dot product cannot be found.\" \n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "lcNerM1vzVwD"
   },
   "source": [
    "## Question 2\n",
    "\n",
    "**[Hamming’s Code]**\n",
    "\n",
    "Create a simple Hamming’s (7,4) algorithm, with the following functionality:\n",
    "1. Write a simple Hamming encoder program in Python, which when given a 4-bit binary value,\n",
    "returns the resulting 7-bit binary vector codeword. Also implement the parity check functionality to see if there are any errors, that is to check whether H ∗ cw =\n",
    "−→0 holds, where −→0 is zero\n",
    "vector.\n",
    "2. Create a decoder program in Python, which when given a 7-bit vector codeword returns the\n",
    "original 4-bit vector word. That is, if we are given a 4-bit word (w), and we apply our encoder\n",
    "to return a codeword (cw = G ∗ w), and then we apply the decoder matrix (R) (fig. 3) to cw,\n",
    "then it should return the original word, such that (R ∗ cw = w).\n",
    "3. Test you code by creating a few 4-bit vectors and running encode and then decode to check if\n",
    "you end up with the original 4-bit vector. Also test your code with some errors and see if the\n",
    "parity check can identify the errors if so to what extent."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "id": "dtIV9_Ni2umw"
   },
   "outputs": [],
   "source": [
    "class hc(object):\n",
    "    \"\"\"\n",
    "    simple Hamming’s (7,4) implementation\n",
    "    \"\"\"\n",
    "    generator_t= [[1,1,0,1],[1,0,1,1],[1,0,0,0],[0,1,1,1],[0,1,0,0],[0,0,1,0],[0,0,0,1]]\n",
    "    pairity_matrix=[[1,0,1,0,1,0,1],[0,1,1,0,0,1,1],[0,0,0,1,1,1,1]]\n",
    "    decoder=[[0,0,1,0,0,0,0],[0,0,0,0,1,0,0],[0,0,0,0,0,1,0],[0,0,0,0,0,0,1]]\n",
    "\n",
    "    def encode(num):\n",
    "        \"\"\"\n",
    "        Hamming (7,4) encoder program in Python, which when given a 4-bit string returns a 7-bit vector codeword.\n",
    "        \"\"\"\n",
    "        # control input type\n",
    "        assert type(num) == str and len(num) == 4, \"input must be a 4 digit and type str\"\n",
    "        \n",
    "        vector=Snumpy.create_vector(num)\n",
    "        encoded_vector = Snumpy.dotproduct(hc.generator_t, vector)\n",
    "        code_word=hc.binary_convert(encoded_vector)\n",
    "        return code_word\n",
    "    \n",
    "    def binary_convert(encoded_vector):\n",
    "        \"\"\"\n",
    "        Helper function for the parity check creates codeword in 0 and 1 value.\n",
    "        \"\"\"\n",
    "        column=len(encoded_vector)\n",
    "        reshaped_word=Snumpy.reshape(encoded_vector, (1,column))\n",
    "        code_word = []\n",
    "        for i in reshaped_word[0]:\n",
    "            if i % 2 == 1:\n",
    "                code_word.append(1)\n",
    "            else:\n",
    "                code_word.append(0)\n",
    "        return code_word\n",
    "    \n",
    "    def parity_check(code_word):\n",
    "        \"\"\"\n",
    "        Hamming (7,4) parity check from, takes a 7-bit vector and it will return True if no error is dectected, \n",
    "        otherwise False is returned\n",
    "        \"\"\"\n",
    "        #control input type\n",
    "        assert type(code_word) == list and len(code_word) == 7 , \"input must to be 7 digit list of numbers\"\n",
    "        \n",
    "        for value in code_word:\n",
    "            assert value in [0,1] , \"digits must be integers with value 0 or 1\"\n",
    "        reshape_code_word = Snumpy.reshape(code_word,(7,1))\n",
    "        syndrome = Snumpy.dotproduct(hc.pairity_matrix,reshape_code_word)\n",
    "        bin_syndrome = hc.binary_convert(syndrome)\n",
    "        \n",
    "        if sum(bin_syndrome)>0:\n",
    "            str_syndrome = \"\".join(str(i) for i in bin_syndrome)\n",
    "            bit_position = int(str_syndrome, 2)\n",
    "            # rewrite the bit positions to match natural reading order for users\n",
    "            if bit_position == 1:\n",
    "                bit_position = 4\n",
    "            elif bit_position == 4:\n",
    "                bit_position = 1\n",
    "            elif bit_position == 3:\n",
    "                bit_position = 6\n",
    "            elif bit_position == 6:\n",
    "                bit_position = 3\n",
    "                \n",
    "            return \"Error detected. Please check bit position \"+ str(bit_position) + \" and correct before decoding\" \n",
    "        else:\n",
    "            return \"No error detected\"     \n",
    "        \n",
    "    def decode(codeword):\n",
    "        \"\"\"\n",
    "        Hamming (7,4) decoder program in Python, which when given a 7-bit vector codeword returns the original 4-bit vector word.\n",
    "        \"\"\"\n",
    "        #control input type\n",
    "        assert type(codeword) == list and len(codeword) == 7 , \"input has to be 7 digit list of numbers\"\n",
    "        \n",
    "        for value in codeword:\n",
    "            #control input value\n",
    "            assert value in [0,1] , \"digits have to be integers with value 0 or 1\"\n",
    "        \n",
    "        v_codeword = Snumpy.reshape(codeword, (7,1))\n",
    "        fin_codeword = Snumpy.dotproduct(hc.decoder,v_codeword)\n",
    "        message = Snumpy.reshape(fin_codeword, (1,4))\n",
    "        res = \"\"\n",
    "        for value in message[0]:\n",
    "            res += str(value)\n",
    "        return res"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "uUZge5Mw2uuQ"
   },
   "source": [
    "### Question 2.1\n",
    "\n",
    "Write a simple Hamming encoder program in Python, which when given a 4-bit binary value, returns the resulting 7-bit binary vector codeword. Also implement the parity check functionality to see if there are any errors, that is to check whether H ∗ cw = −→0 holds, where −→0 is zero vector."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "id": "SYl2ernFpZlS"
   },
   "outputs": [],
   "source": [
    "#Test if the origal message can be encoded to code word correctly\n",
    "assert hc.encode('1001') == [0, 0, 1, 1, 0, 0, 1]\n",
    "assert hc.encode('0001') == [1, 1, 0, 1, 0, 0, 1]\n",
    "assert hc.encode('0101') == [0, 1, 0, 0, 1, 0, 1]\n",
    "assert hc.encode('1111') == [1, 1, 1, 1, 1, 1, 1]\n",
    "assert hc.encode('0000') == [0, 0, 0, 0, 0, 0, 0]\n",
    "assert hc.encode('1000') == [1, 1, 1, 0, 0, 0, 0]\n",
    "\n",
    "#Test wrong inputs\n",
    "    #input is not 4-digit\n",
    "try :\n",
    "    hc.encode('100')\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input have to be a 4 digit and type str\"\n",
    "\n",
    "    #input is wrong type\n",
    "try :\n",
    "    hc.encode(1001)\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input have to be a 4 digit and type str\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "id": "56pnvAqpqzoy"
   },
   "outputs": [],
   "source": [
    "#Test if the function can detect errors and tell the position of the wrong bit correctly\n",
    "# word = '1001' and correct codeword = [0, 0, 1, 1, 0, 0, 1]\n",
    "assert hc.parity_check([0, 0, 1, 1, 0, 0, 1]) == \"No error detected\"\n",
    "\n",
    "#Test flip bit position 1\n",
    "assert hc.parity_check([1, 0, 1, 1, 0, 0, 1]) == 'Error detected. Please check bit position 1 and correct before decoding'\n",
    "#Test flip bit position 2\n",
    "assert hc.parity_check([0, 1, 1, 1, 0, 0, 1]) == 'Error detected. Please check bit position 2 and correct before decoding'\n",
    "#Test flip bit position 3\n",
    "assert hc.parity_check([0, 0, 0, 1, 0, 0, 1]) == 'Error detected. Please check bit position 3 and correct before decoding'\n",
    "#Test flip bit position 4\n",
    "assert hc.parity_check([0, 0, 1, 0, 0, 0, 1]) == 'Error detected. Please check bit position 4 and correct before decoding'\n",
    "#Test flip bit position 5 \n",
    "assert hc.parity_check([0, 0, 1, 1, 1, 0, 1]) == 'Error detected. Please check bit position 5 and correct before decoding'\n",
    "#Test flip bit position 6\n",
    "assert hc.parity_check([0, 0, 1, 1, 0, 1, 1]) == 'Error detected. Please check bit position 6 and correct before decoding'\n",
    "#Test flip bit position 7\n",
    "assert hc.parity_check([0, 0, 1, 1, 0, 0, 0]) == 'Error detected. Please check bit position 7 and correct before decoding'\n",
    "\n",
    "# The parity_check function is able to tell the position of the wrong bit\n",
    "\n",
    "#Test wrong inputs\n",
    "    #input is wrong value\n",
    "try :\n",
    "    hc.parity_check([0, 0, 0, 0, 0, 0])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input has to be 7 digit list of numbers\"\n",
    "\n",
    "    #input is wrong type\n",
    "try :\n",
    "    hc.parity_check(\"0000001\")\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input has to be 7 digit list of numbers\"\n",
    "\n",
    "    #input is wrong value\n",
    "try :\n",
    "    hc.parity_check([2, 1, 1, 0, 0, 1, 0])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"digits have to be integers with value 0 or 1\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "huh0ZHsF2zv4"
   },
   "source": [
    "### Question 2.2\n",
    "\n",
    "Create a decoder program in Python, which when given a 7-bit vector codeword returns the original 4-bit vector word. That is, if we are given a 4-bit word (w), and we apply our encoder to return a codeword (cw = G ∗ w), and then we apply the decoder matrix (R) (fig. 3) to cw, then it should return the original word, such that (R ∗ cw = w)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "id": "29ahnkRwuhsZ"
   },
   "outputs": [],
   "source": [
    "#Test if code word can be decoded to the original message\n",
    "assert '1001' == hc.decode([0, 0, 1, 1, 0, 0, 1])\n",
    "assert '0001' == hc.decode([1, 1, 0, 1, 0, 0, 1])\n",
    "assert '0101' == hc.decode([0, 1, 0, 0, 1, 0, 1])\n",
    "assert '1111' == hc.decode([1, 1, 1, 1, 1, 1, 1])\n",
    "assert '0000' == hc.decode([0, 0, 0, 0, 0, 0, 0])\n",
    "assert '1000' == hc.decode([1, 1, 1, 0, 0, 0, 0])\n",
    "\n",
    "#Test wrong inputs\n",
    "    #input is wrong value\n",
    "try :\n",
    "    hc.decode([0, 0, 0, 0, 0, 0])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input has to be 7 digit list of numbers\"\n",
    "\n",
    "    #input is wrong type\n",
    "try :\n",
    "    hc.decode(\"0000001\")\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"input has to be 7 digit list of numbers\"\n",
    "\n",
    "    #input is wrong value\n",
    "try :\n",
    "    hc.decode([0, 1, 1, 0, 2, 1, 0])\n",
    "    raise BaseException(\"code should never get here\")\n",
    "except AssertionError as error:\n",
    "    assert str(error)== \"digits have to be integers with value 0 or 1\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "sbG-jWMj3Oga"
   },
   "source": [
    "### Question 2.3\n",
    "\n",
    "Test you code by creating a few 4-bit vectors and running encode and then decode to check if you end up with the original 4-bit vector. Also test your code with some errors and see if the parity check can identify the errors if so to what extent."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3-bit errors cannot be detected\n"
     ]
    }
   ],
   "source": [
    "#Please see the main encode test in 2.1 and decode test in 2.2; we concludes the following;\n",
    "    #Encode function can encode original word into codeword\n",
    "    #Decode function can decode codeword to its original word\n",
    "    #Parity_check function can indicate the position of the 1-bit error correctly\n",
    "#running encode\n",
    "assert hc.encode('1001') == [0, 0, 1, 1, 0, 0, 1]\n",
    "#running decode\n",
    "assert hc.decode([0, 0, 1, 1, 0, 0, 1]) == '1001'\n",
    "    \n",
    "#running Parity_check function to see how much it can detect errors\n",
    "# We have tested that 1-bit errors can be detected at any position\n",
    "\n",
    "#Test with 2-bit errors to see whether they are detected\n",
    "    #wrong bits at position 1,2\n",
    "assert hc.parity_check([1, 1, 1, 1, 0, 0, 1]) == 'Error detected. Please check bit position 3 and correct before decoding'\n",
    "    #wrong bits at position 2,3\n",
    "assert hc.parity_check([0, 1, 0, 1, 0, 0, 1]) == 'Error detected. Please check bit position 1 and correct before decoding'\n",
    "    #wrong bits at position 3,4\n",
    "assert hc.parity_check([0, 0, 0, 0, 0, 0, 1]) == 'Error detected. Please check bit position 7 and correct before decoding'\n",
    "    #wrong bits at position 4,5\n",
    "assert hc.parity_check([0, 0, 1, 0, 1, 0, 1]) == 'Error detected. Please check bit position 1 and correct before decoding'\n",
    "    #wrong bits at position 5,6\n",
    "assert hc.parity_check([0, 0, 1, 1, 1, 1, 1]) == 'Error detected. Please check bit position 3 and correct before decoding'\n",
    "    #wrong bits at position 6,7\n",
    "assert hc.parity_check([0, 0, 1, 1, 0, 1, 0]) == 'Error detected. Please check bit position 1 and correct before decoding'\n",
    "\n",
    "#2-bit errors still are detected. However, the parity check function cannot indicate correctly which positions are corrupted\n",
    "\n",
    "#Test with 3 wrong bits;\n",
    "try:\n",
    "    assert hc.parity_check([1, 1, 0, 1, 0, 0, 1]) == 'Error detected. Please check bit position 1 and correct before decoding'\n",
    "    raise BaseException(\"The parity check function can detect 3-bit errors\")\n",
    "except:\n",
    "    print('3-bit errors cannot be detected')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "scrolled": true
   },
   "source": [
    "In conclusion, Hamming's code can correct 1-bit errors and can detect up to 2-bit errors."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 3\n",
    "[Text Document Similarity]\n",
    "Create a python program that will compute the text document similarity between different docu\u0002ments. Your implementation will take a list of documents as an input text corpus and it will compute\n",
    "a dictionary of words for the given corpus. Later, when a new document (i.e search document) is pro\u0002vided, your implementation should provide a list of documents that are similar to the given search\n",
    "document, in descending order of their similarity with the search document.\n",
    "For computing similarity between any two documents in our question, you can use the following\n",
    "distance measures (optionally you can also use any other measure as well).\n",
    "1. dot product between the two vectors\n",
    "2. distance norm (or Euclidean distance) between two vectors .e.g. || u − v ||\n",
    "As part of answering the question, you can also compare and comment on which of the two\n",
    "methods (or any other measure if you have used some other measure) will perform better and what\n",
    "are the reasons for it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Search_Engine(object):\n",
    "\n",
    "    #We created the Search Engine class so that our code would be able to search multiple stored repositories. \n",
    "    #It it less elegent but it allows for more versatility in usage\n",
    "    def __init__(self):\n",
    "        self.corpus_list=[]\n",
    "        self.corpus_set=set()\n",
    " \n",
    "    def add_file(self, file_pathway):\n",
    "    #We chose that files would be added in our Search Engine class rather than our Corpus class because we saw the corpus class \n",
    "    #as a storage repository for all files. By adding them in the Search Engine we can create an iterable respository \n",
    "    #of our documents that are known outside the document class and are kept more tidy. \n",
    "\n",
    "        \"\"\"\n",
    "        add_file is a way to add a file to the respository of documents in order to search them. \n",
    "        add_file takes a file pathway to a .txt file and saves the text and the file name as the file_id\n",
    "\n",
    "        \"\"\"\n",
    "        text_file = open(file_pathway, \"r\")\n",
    "        text = text_file.read()\n",
    "        text_file.close()\n",
    "        name = file_pathway.split('.')\n",
    "        filename = name[0].split('/')\n",
    "        text_id = filename[-1]\n",
    "        corpus = Corpus(text_id, text)\n",
    "        if corpus not in self.corpus_set:\n",
    "            self.corpus_set.add(corpus)\n",
    "        else:\n",
    "            raise ValueError (\"Text_id must be unique\")\n",
    "        self.corpus_list.append(corpus)\n",
    "        return corpus\n",
    "  \n",
    "    def add_string(self, text_id, text):\n",
    "        \"\"\"\n",
    "        add_string is a way to add a sring to the respository of documents in order to search them. \n",
    "        add_string takes two arguments of a text_id and the string of actual text for parsing.\n",
    "\n",
    "        \"\"\"\n",
    "        corpus = Corpus(text_id, text)\n",
    "        if corpus not in self.corpus_set:\n",
    "            self.corpus_set.add(corpus)\n",
    "        else:\n",
    "            raise ValueError (\"Text_id must be unique\")\n",
    "        self.corpus_list.append(corpus)\n",
    "        return corpus\n",
    "  \n",
    "    def assess_all(self, comp_corpus):\n",
    "        \"\"\"\n",
    "        assess_all provides a way to compare a known document to the repository of documnets. \n",
    "        It takes the argument of the document you want to compare and will run an analysis and \n",
    "        returns an ordered list of documents with the percent similarity. \n",
    "        \"\"\"\n",
    "\n",
    "        simi_dict={}\n",
    "        for corpus in self.corpus_list:\n",
    "            simi_points=corpus.assess(corpus, comp_corpus)\n",
    "            simi_dict[corpus.text_id] = simi_points\n",
    "        #this first block runs a loop and stores the text_id and dot product of all of the corpus objects \n",
    "        #in the Search Engine's document_list\n",
    "        comp_value = simi_dict[comp_corpus.text_id]\n",
    "        #comp_value is the value of the dot product for the comparison corpus and itself. \n",
    "        #This value allows the computation of the percent similarity\n",
    "        del simi_dict[comp_corpus.text_id]\n",
    "        #We've removed the same object from the list so that only non-same documents will be compared\n",
    "        sort = sorted(simi_dict.items(), key=lambda x: x[1], reverse=True)\n",
    "        #sorting the results by the keys so the results will be in order from largest to smallest\n",
    "        percent_dict={}\n",
    "        for x in range(len(sort)):\n",
    "            comp2_value = sort[x][1]\n",
    "            percent= \"{:.2%}\".format((comp2_value/comp_value))\n",
    "            percent_dict[sort[x][0]]=percent\n",
    "        #can add stop after n instances\n",
    "        #This returns a new dictionary with the text_id and the percent similarity. We chose a new \n",
    "        #dictionary because our simi_dict stored data as a tuple\n",
    "        print(\"File Name\", \"\\t\\t\",\"Percent Similarity\")\n",
    "        for x in percent_dict:\n",
    "            print(\"%-20s\" % x, \"%10s\" % percent_dict.get(x))\n",
    "\n",
    "\n",
    "class Corpus(object):\n",
    "    \n",
    "    #This is a class for storing thee documents for the search engine. \n",
    "\n",
    "    def __init__(self, text_id, text): \n",
    "        self.text_id = text_id\n",
    "        self.text = text.lower()\n",
    "        cleaned_text = text.translate(str.maketrans('', '','!\"#$%&()*+,-./:;<=>?@[\\]^_`{|}~'))\n",
    "        split_text = cleaned_text.split()\n",
    "        self.dict = {i: split_text.count(i) for i in split_text}\n",
    "        \n",
    "    def __hash__(self):\n",
    "        return self.text_id.__hash__()\n",
    "    \n",
    "    def __eq__(self, other):\n",
    "        if isinstance(other, Corpus):\n",
    "            return ((self.text_id == other.text_id))\n",
    "        else:\n",
    "            return False\n",
    "    \n",
    "    def __str__(self):\n",
    "        return self.text_id\n",
    "\n",
    "    def assess(self, comp_corpus, corpus):\n",
    "        comp_vector = []\n",
    "        comp_freq= []  \n",
    "        for key in comp_corpus.dict.keys():\n",
    "            if key in corpus.dict.keys():\n",
    "                comp_vector.append(1)\n",
    "                comp_freq.append(self.dict.get(key)/comp_corpus.dict.get(key))\n",
    "            else:\n",
    "                comp_vector.append(0)\n",
    "                comp_freq.append(0)\n",
    "        simi_points = Snumpy.dotproduct(comp_vector, comp_freq)\n",
    "        return simi_points"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "File Name \t\t Percent Similarity\n",
      "alpha1                   87.50%\n",
      "alpha2                   75.00%\n",
      "alpha3                   62.50%\n"
     ]
    }
   ],
   "source": [
    "Simple=Search_Engine()\n",
    "alphabet=Simple.add_string(\"alpha\",\"a b c d e f g h\")\n",
    "alphabet1=Simple.add_string(\"alpha1\",\"a b c d e f g\")\n",
    "alphabet2=Simple.add_string(\"alpha2\",\"a b c d e f\")\n",
    "alphabet3=Simple.add_string(\"alpha3\",\"a b c d e\")\n",
    "Simple.assess_all(alphabet)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "File Name \t\t Percent Similarity\n",
      "Kent                     15.00%\n",
      "Gloucester               15.00%\n",
      "Edmund                   14.17%\n"
     ]
    }
   ],
   "source": [
    "#test code\n",
    "KingLear=Search_Engine()\n",
    "Lear=KingLear.add_string(\"Lear_Mono\",\"Meantime we shall express our darker purpose.--Give me the map there.\t[He is handed a map.] Know that we have divided In three our kingdom, and 'tis our fast intent To shake all cares and business from our age, Conferring them on younger strengths, while we Unburdened crawl toward death. Our son of Cornwall And you, our no less loving son of Albany, We have this hour a constant will to publish Our daughters' several dowers, that future strife May be prevented now. The two great princes, France and Burgundy, Great rivals in our youngest daughter's love, Long in our court have made their amorous sojourn And here are to be answered. Tell me, my daughters-- Since now we will divest us both of rule, Interest of territory, cares of state-- Which of you shall we say doth love us most, That we our largest bounty may extend Where nature doth with merit challenge. Goneril, Our eldest born, speak first.\")\n",
    "Kent=KingLear.add_string(\"Kent\",\"Let it fall rather, though the fork invade The region of my heart. Be Kent unmannerly When Lear is mad. What wouldst thou do, old man? Think'st thou that duty shall have dread to speak When power to flattery bows? To plainness honor's bound When majesty falls to folly. Reserve thy state, And in thy best consideration check This hideous rashness. Answer my life my judgment, Thy youngest daughter does not love thee least, Nor are those empty-hearted whose low sounds Reverb no hollowness.\")\n",
    "Gloucer=KingLear.add_string(\"Gloucester\",\"These late eclipses in the sun and moon portend no good to us. Though the wisdom of nature can reason it thus and thus, yet nature finds itself scourged by the sequent effects. Love cools, friendship falls off, brothers divide; in cities, mutinies; in countries, discord; in palaces, treason; and the bond cracked 'twixt son and father. This villain of mine comes under the prediction: there's son against father. The King falls from bias of nature: there's father against child. We have seen the best of our time. Machinations, hollowness, treachery, and all ruinous disorders follow us disquietly to our graves.--Find out this villain, Edmund. It shall lose thee nothing. Do it carefully.--And the noble and true-hearted Kent banished! His offense, honesty! 'Tis strange.\t[He exits.]\")\n",
    "Edmund=KingLear.add_string(\"Edmund\",\"That when we are sick in fortune (often the surfeits of our own behavior) we make guilty of our disasters the sun, the moon, and stars, as if we were villains on necessity; fools by heavenly compulsion; knaves, thieves, and treachers by spherical predominance; drunkards, liars, and adulterers by an enforced obedience of planetary influence; and all that we are evil in, by a divine thrusting on. An admirable evasion of whoremaster man, to lay his goatish disposition on the charge of a star! My father compounded with my mother under the Dragon's tail, and my nativity was under Ursa Major, so that it follows I am rough and lecherous. Fut, I should have been that I am, had the maidenliest star in the firmament twinkled on my bastardizing. Edgar-- and pat he comes like the catastrophe of the old comedy. My cue is villainous melancholy, with a sigh like Tom o' Bedlam.--O, these eclipses do portend these divisions. Fa, sol, la, mi.\")\n",
    "KingLear.assess_all(Lear)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [],
   "name": "Copy of Foundations Final 16.12.21",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
